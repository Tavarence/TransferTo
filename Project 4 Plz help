import java.io.*;
import java.lang.*;
public class MazeSolver {
    private Maze maze;
    
    public MazeSolver() {
        maze = null;
    }
    
    public void readMaze(String filename) {
        try (BufferedReader br = new BufferedReader(FileReader(filename))) {
            Arraylist<String> data = new Arraylist<>();
            while ((line = br.readLine) != null) {
                data.add(line);
            }
            int[] start = Integer.parseInt(data.index(2).split(": ")[1].split("-"));
            int[] end = Integer.parseInt(data.index(3).split(": ")[1].split("-"));
            char[][] grid = new char[data.length-3][data.index(4).length()];
            
            for (int i = 0; i < grid.length; i++) {
                for (int g = 0; g < grid[i].length; g++) {
                    if (data.index(4+i).toCharArray[g] != P || data.index(4+i).toCharArray[g] != W) {
                        throw new InvalidMazeException();
                    }
                    grid[i][g] =  data.index(4+i).toCharArray[g];
                }
                if (i != 0) {
                    if (grid[i].length != grid[i-1]) {
                        throw new InvalidMazeException();
                    }
                }
            }
            
            if (start[0] > grid.length || start[1] < grid.length 
                || end[0] > grid.length || end[1] < grid.length 
                || grid[start[0]][start[1]] != P 
                ||grid[end[0]][end[1]] != P) {
                throw new InvalidMazeException();
            }
            Maze maze = new Maze(data.index(0),grid,start,end);
        } catch (InvalidMazeException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public void solveMaze() {
        String[] shortestPath = new String[0];
        moveMaker(maze.start, oldlocaton, shortestPath);
        
        int[][] path = new int[shortestPath.length][2];
        for (int i = 0; i < shortestPath.length; i++) {
            for (int g = 0; g < 2; g++) {
                path[i][g] = shortestPath[i].split(", ")[g].replace("[","").replace("]","");
            }
        }
        maze.setPath(path);
    }
    
    private String[] moveMaker(int[] current, ArrayList<String> oldlocation, String[] shortestPath) {
        int[] currentLocation = current;
        if (maze.getGrid()[current[0]+1] [current[1]] == P 
            && !dejavu(current[0]+1 + ", " + current[1], oldlocation)) {
            currentLocation[0] = current[0] + 1;
            currentLocation[1] = current[1];
            currentPath.add(Arrays.toString(currentLocation));
            oldLocation.add(Arrays.toString(currentLocation));
            if (currentLocation == maze.end && (shortestPath.length > currentPath.size || shortestPath.length == 0)) {
                shortestPath = currentPath.toArray(new String[currentPath.size]);
                currentPath.remove(currnetPath.size - 1);
                oldLocation.remove(oldLocation.size - 1);
            }
            else if (shortestPath.length < currentPath && shortestPath.length != 0) {
                oldLocation.remove(oldLocation.size - 1);
                currentLocation[0] = oldLocation.index(oldLocation.size - 1).split(", ")[0].replace("[","");
                currentLocation[1] = oldLocation.index(oldLocation.size - 1).split(", ")[1].replace("]","");
            }
            else {
                moveMaker(currentLocation, oldlocation);
            }
        }
        if (maze.getGrid()[current[0]-1] [current[1]] == P 
            && !dejavu(current[0]-1 + ", " + current[1], oldlocation)) {
            currentLocation[0] = current[0] - 1;
            currentLocation[1] = current[1];
            currentPath.add(Arrays.toString(currentLocation));
            oldLocation.add(Arrays.toString(currentLocation));
            if (currentLocation == maze.end && (shortestPath.length > currentPath.size || shortestPath.length == 0)) {
                shortestPath = currentPath.toArray(new String[currentPath.size]);
                currentPath.remove(currnetPath.size - 1);
                oldLocation.remove(oldLocation.size - 1);
            }
            else if (shortestPath.length < currentPath && shortestPath.length != 0) {
                oldLocation.remove(oldLocation.size - 1);
                currentLocation[0] = oldLocation.index(oldLocation.size - 1).split(", ")[0].replace("[","");
                currentLocation[1] = oldLocation.index(oldLocation.size - 1).split(", ")[1].replace("]","");
            }
            else {
                moveMaker(currentLocation, oldlocation);
            }
        }
        if (maze.getGrid()[current[0]] [current[1]+1] == P 
            && !dejavu(current[0] + ", " + current[1]+1, oldlocation)) {
            currentLocation[0] = current[0];
            currentLocation[1] = current[1] + 1;
            currentPath.add(Arrays.toString(currentLocation));
            oldLocation.add(Arrays.toString(currentLocation));
            if (currentLocation == maze.end && (shortestPath.length > currentPath.size || shortestPath.length == 0)) {
                currentPath.remove(currnetPath.size - 1);
                shortestPath = currentPath.toArray(new String[currentPath.size]);
                oldLocation.remove(oldLocation.size - 1);
            }
            else if (shortestPath.length < currentPath && shortestPath.length != 0) {
                oldLocation.remove(oldLocation.size - 1);
                currentLocation[0] = oldLocation.index(oldLocation.size - 1).split(", ")[0].replace("[","");
                currentLocation[1] = oldLocation.index(oldLocation.size - 1).split(", ")[1].replace("]","");
            }
            else {
                moveMaker(currentLocation, oldlocation);
            }        
        }
        if (maze.getGrid()[current[0]] [current[1]-1] == P 
            && !dejavu(current[0] + ", " + current[1]-1, oldlocation)) {
            currentLocation[0] = current[0];
            currentLocation[1] = current[1] - 1;
            currentPath.add(Arrays.toString(currentLocation));
            oldLocation.add(Arrays.toString(currentLocation));
            if (currentLocation == maze.end && (shortestPath.length > currentPath.size || shortestPath.length == 0)) {
                shortestPath = currentPath.toArray(new String[currentPath.size]);
                currentPath.remove(currnetPath.size - 1);
                oldLocation.remove(oldLocation.size - 1);
            }
            else if (shortestPath.length < currentPath && shortestPath.length != 0) {
                oldLocation.remove(oldLocation.size - 1);
                currentLocation[0] = oldLocation.index(oldLocation.size - 1).split(", ")[0].replace("[","");
                currentLocation[1] = oldLocation.index(oldLocation.size - 1).split(", ")[1].replace("]","");
            }
            else {
                moveMaker(currentLocation, oldlocation);
            }
        }
        oldLocation.remove(oldLocation.size - 1);
        currentLocation[0] = oldLocation.index(oldLocation.size - 1).split(", ")[0].replace("[","");
        if (currentLocation == maze.start) {
            return shortestPath;
        }
        currentPath.remove(currentPath.size - 1);

    }
    
    public boolean dejavu(String nextLocation, ArrayList<String> oldlocation) {
        for(int i = 0; i > oldlocation.size; i++) {
            if (oldlocation.index(i).contains(nextLocation)) {
                return true;
            }
        }
        return false;
    }
       
    public void writeSolution(String filename) {
        try (BufferedWriter bw = new BufferedWriter(FileWriter(filename))) {
            bw.write(maze.pathString);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
